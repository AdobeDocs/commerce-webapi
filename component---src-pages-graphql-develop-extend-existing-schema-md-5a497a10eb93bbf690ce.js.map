{"version":3,"file":"component---src-pages-graphql-develop-extend-existing-schema-md-5a497a10eb93bbf690ce.js","mappings":"0RAMaA,EAAe,CAAC,EACvBC,EAAc,CAClBD,gBAEIE,EAAYC,EAAAA,EACH,SAASC,EAAW,GAGhC,IAHgC,WACjCC,GAED,EADIC,GAAK,YAER,OAAO,SAACJ,GAAS,UAAKD,EAAiBK,EAAK,CAAED,WAAYA,EAAYE,QAAQ,eAG5E,eACE,GAAM,qCACH,sCACL,kBAAK,+KAA6K,eAAIC,WAAW,KAAM,aAAkB,oGAAkG,uBAAYA,WAAW,KAAM,mBAAgC,6PACxX,eACE,GAAM,qBACH,sBACL,kBAAK,+GACL,kBAAK,mFAAiF,uBAAYA,WAAW,KAAM,oBAAiC,2BAAyB,uBAAYA,WAAW,KAAM,sBAAmC,oCAAkC,uBAAYA,WAAW,KAAM,YAAyB,oEAAkE,cAAGA,WAAW,IACjZ,KAAQ,uFACL,sBAA0B,0DACjC,kBAAK,qEACL,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBACV,kQAsBP,kBAAK,0BAAwB,uBAAYA,WAAW,KAAM,oBAAiC,kFAAgF,uBAAYA,WAAW,KAAM,mBAAgC,kCAAgC,uBAAYA,WAAW,KAAM,yBAAsC,MAAI,uBAAYA,WAAW,KAAM,OAAoB,gBAChY,mBAAG,uBAAYA,WAAW,KAAM,+CAChC,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBACV,8WAQP,kBAAK,+DAA6D,uBAAYA,WAAW,KAAM,8CAA2D,iCAA+B,uBAAYA,WAAW,KAAM,oBAAiC,4DACvP,oBACE,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAO,QAAM,uBAAYA,WAAW,KAAM,oBAAiC,sIAAoI,uBAAYA,WAAW,KAAM,oBAAiC,2CAAyC,uBAAYA,WAAW,KAAM,QAAqB,+DAExX,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAO,QAAM,uBAAYA,WAAW,KAAM,sBAAmC,8EAA4E,uBAAYA,WAAW,KAAM,oBAAiC,gIAGzO,eACE,GAAM,2BACH,4BACL,kBAAK,2DAAyD,uBAAYA,WAAW,KAAM,UAAuB,SAAO,uBAAYA,WAAW,KAAM,SAAsB,mBAAiB,uBAAYA,WAAW,KAAM,WAAwB,oGAClP,kBAAK,oCAAkC,uBAAYA,WAAW,KAAM,0DAAuE,kFAAgF,uBAAYA,WAAW,KAAM,UAAuB,+DAC/Q,mBAAG,uBAAYA,WAAW,KAAM,8EAChC,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBACV,q6BA8BP,eACE,GAAM,6BACH,8BACL,kBAAK,8CAA4C,uBAAYA,WAAW,KAAM,eAA4B,mCAC1G,kBAAK,mDAAiD,uBAAYA,WAAW,KAAM,sBAAmC,YAAU,uBAAYA,WAAW,KAAM,YAAyB,gCAA8B,uBAAYA,WAAW,KAAM,sBAAmC,WACpR,kBAAK,oDAAkD,uBAAYA,WAAW,KAAM,sBAAmC,uCAAqC,uBAAYA,WAAW,KAAM,2BAAwC,MACjO,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBACV,yeAWP,kBAAK,kCAAgC,uBAAYA,WAAW,KAAM,eAA4B,mBAAiB,uBAAYA,WAAW,KAAM,uBAAoC,2BAChL,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBACV,gIAIP,eACE,GAAM,kBACH,mBACL,oBACE,eAAIA,WAAW,OAAK,cAAGA,WAAW,KAC9B,KAAQ,YACL,4CACP,eAAIA,WAAW,OAAK,cAAGA,WAAW,KAC9B,KAAQ,gBACL,eACP,eAAIA,WAAW,OAAK,cAAGA,WAAW,KAC9B,KAAQ,uFACL,wBAIb,CAEAJ,EAAWK,gBAAiB,C","sources":["webpack://commerce-webapi/./src/pages/graphql/develop/extend-existing-schema.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/commerce-webapi/commerce-webapi/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"extend-an-existing-graphql-schema\"\n    }}>{`Extend an existing GraphQL schema`}</h1>\n    <p>{`You can extend the default GraphQL schema to add attributes and data types, modify existing resolver behavior, and add features using other extension points. GraphQL uses `}<em parentName=\"p\">{`stitching`}</em>{` to assemble a single unified schema out of the many schemas defined in individual modules. All `}<inlineCode parentName=\"p\">{`schema.graphqls`}</inlineCode>{` files are stitched together to a single schema. In this process, all nodes with the same type (such as type, interface, and enum) and name are stitched together and recursively extended/overridden. This process is similar to how XML merging works.`}</p>\n    <h2 {...{\n      \"id\": \"extend-the-schema\"\n    }}>{`Extend the schema`}</h2>\n    <p>{`The first step to retrieve a custom field in an existing query is to extend the appropriate schema object.`}</p>\n    <p>{`In the following example, we will change the description of an existing field (`}<inlineCode parentName=\"p\">{`attribute_set_id`}</inlineCode>{`) and add a new field (`}<inlineCode parentName=\"p\">{`attribute_set_name`}</inlineCode>{`) to the GraphQL schema for the `}<inlineCode parentName=\"p\">{`products`}</inlineCode>{` query. Common use cases require adding fields to the database. `}<a parentName=\"p\" {...{\n        \"href\": \"https://developer.adobe.com/commerce/php/development/components/declarative-schema/\"\n      }}>{`Declarative Schema`}</a>{` describes how to add a custom field to the database.`}</p>\n    <p>{`The simplified structure of the query schema to get products is:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`schema {\n    query: Query\n    ...\n}\n\ntype Query {\n    products (...): Products\n    ...\n}\n\ntype Products {\n    items: [ProductInterface]\n    ...\n}\n\ninterface ProductInterface {\n    id: Int\n    name: String\n    sku: String\n    ...\n}\n`}</code></pre>\n    <p>{`We need to extend the `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{`, since that is the schema object for a product. We can do this by creating a `}<inlineCode parentName=\"p\">{`schema.graphqls`}</inlineCode>{` file in our custom module's (`}<inlineCode parentName=\"p\">{`ExampleCorp/CustomGQL`}</inlineCode>{`) `}<inlineCode parentName=\"p\">{`etc`}</inlineCode>{` directory.`}</p>\n    <p><inlineCode parentName=\"p\">{`ExampleCorp_CustomGQL/etc/schema.graphqls`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`interface ProductInterface {\n    attribute_set_id: Int\n        @doc(description: \"ID of the attribute set assigned to the product\")\n    attribute_set_name: String\n        @doc(description: \"Name of attribute set assigned to the product\")\n        @resolver(class: \"\\\\\\\\ExampleCorp\\\\\\\\CustomGQL\\\\\\\\Model\\\\\\\\Resolver\\\\\\\\ProductAttributeSetNameResolver\")\n}\n`}</code></pre>\n    <p>{`The above schema file is merged with the schema present at `}<inlineCode parentName=\"p\">{`Magento_CatalogGraphQl/etc/schema.graphqls`}</inlineCode>{` which contains the original `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{` object. Our schema file contains the following fields:`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`The `}<inlineCode parentName=\"p\">{`attribute_set_id`}</inlineCode>{` field is already present in the original schema, so the field described in our new schema will override the field present in the `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{` object. This example only changes the `}<inlineCode parentName=\"p\">{`@doc`}</inlineCode>{` annotation content to demonstrate how the process works.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`The `}<inlineCode parentName=\"p\">{`attribute_set_name`}</inlineCode>{` field is not present in the orignal schema, so the field is added to the `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{` object by extending it. For our new field, we set a description and a resolver class to resolve the data to be returned.`}</p>\n      </li>\n    </ul>\n    <h2 {...{\n      \"id\": \"resolve-the-field-value\"\n    }}>{`Resolve the field value`}</h2>\n    <p>{`In the resolver, we get the relevant data based on the `}<inlineCode parentName=\"p\">{`$value`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`$args`}</inlineCode>{` passed to the `}<inlineCode parentName=\"p\">{`resolve`}</inlineCode>{` method. This can be done using a repository interface or a resource model of the custom field.`}</p>\n    <p>{`In our example scenario, we use `}<inlineCode parentName=\"p\">{`Magento\\\\Catalog\\\\Api\\\\AttributeSetRepositoryInterface`}</inlineCode>{` to get the attribute set name for a given attribute set ID obtained from the `}<inlineCode parentName=\"p\">{`$value`}</inlineCode>{` argument and return that as the resolution for the field.`}</p>\n    <p><inlineCode parentName=\"p\">{`ExampleCorp_CustomGQL/Model/Resolver/ProductAttributeSetNameResolver.php`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`<?php\n\nnamespace ExampleCorp\\\\CustomGQL\\\\Model\\\\Resolver;\n\nuse Magento\\\\Catalog\\\\Api\\\\AttributeSetRepositoryInterface;\nuse Magento\\\\Framework\\\\GraphQl\\\\Config\\\\Element\\\\Field;\nuse Magento\\\\Framework\\\\GraphQl\\\\Query\\\\ResolverInterface;\nuse Magento\\\\Framework\\\\GraphQl\\\\Schema\\\\Type\\\\ResolveInfo;\n\n/**\n * Class to resolve custom attribute_set_name field in product GraphQL query\n */\nclass ProductAttributeSetNameResolver implements ResolverInterface\n{\n    /**\n     * @var AttributeSetRepositoryInterface\n     */\n    private $setRepository;\n\n    public function __construct(AttributeSetRepositoryInterface $setRepository)\n    {\n        $this->setRepository = $setRepository;\n    }\n\n    public function resolve(Field $field, $context, ResolveInfo $info, array $value = null, array $args = null)\n    {\n        return $this->setRepository->get($value['attribute_set_id'])->getAttributeSetName();\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"extend-configuration-data\"\n    }}>{`Extend configuration data`}</h2>\n    <p>{`You can add your own configuration to the `}<inlineCode parentName=\"p\">{`storeConfig`}</inlineCode>{` query within your own module.`}</p>\n    <p>{`To do this, configure the constructor argument `}<inlineCode parentName=\"p\">{`extendedConfigData`}</inlineCode>{` in the `}<inlineCode parentName=\"p\">{`argument`}</inlineCode>{` node in your area-specific `}<inlineCode parentName=\"p\">{`etc/graphql/di.xml`}</inlineCode>{` file.`}</p>\n    <p>{`The following example adds an array-item to the `}<inlineCode parentName=\"p\">{`extendedConfigData`}</inlineCode>{` array within the construct of the `}<inlineCode parentName=\"p\">{`StoreConfigDataProvider`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-xml\"\n      }}>{`<?xml version=\"1.0\" ?>\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"urn:magento:framework:ObjectManager/etc/config.xsd\">\n  <type name=\"Magento\\\\StoreGraphQl\\\\Model\\\\Resolver\\\\Store\\\\StoreConfigDataProvider\">\n    <arguments>\n      <argument name=\"extendedConfigData\" xsi:type=\"array\">\n        <item name=\"section_group_field\" xsi:type=\"string\">section/group/field</item>\n      </argument>\n    </arguments>\n  </type>\n</config>\n`}</code></pre>\n    <p>{`You must also extend the type `}<inlineCode parentName=\"p\">{`storeConfig`}</inlineCode>{` within in the `}<inlineCode parentName=\"p\">{`etc/schema.graphqls`}</inlineCode>{` file, as shown below:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type StoreConfig {\n    section_group_field : String  @doc(description: \"Extended Config Data - section/group/field\")\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"related-topics\"\n    }}>{`Related topics`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"index.md\"\n        }}>{`Define the GraphQL schema for a module`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"resolvers.md\"\n        }}>{`Resolvers`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://developer.adobe.com/commerce/php/development/components/declarative-schema/\"\n        }}>{`Declarative schema`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}