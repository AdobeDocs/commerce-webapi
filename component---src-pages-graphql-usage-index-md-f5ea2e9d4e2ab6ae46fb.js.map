{"version":3,"file":"component---src-pages-graphql-usage-index-md-f5ea2e9d4e2ab6ae46fb.js","mappings":"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","sources":["webpack://commerce-webapi/./src/pages/graphql/usage/index.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/commerce-webapi/commerce-webapi/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\nconst InlineAlert = makeShortcode(\"InlineAlert\");\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"run-graphql-queries-and-mutations\"\n    }}>{`Run Graphql queries and mutations`}</h1>\n    <h2 {...{\n      \"id\": \"queries\"\n    }}>{`Queries`}</h2>\n    <p>{`A GraphQL query retrieves data from the application server in a similar manner as a REST GET call. The current set of Adobe Commerce and Magento Open Source GraphQL queries allow a mobile app or browser to render a wide variety of information, including the following:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`A set of products to be displayed. This can include the entire catalog or those that match customer-specified criteria.`}</li>\n      <li parentName=\"ul\">{`Customer data. With a customer token, a query can retrieve basic information about a customer as well as billing and shipping addresses, wish lists, order history, and other sensitive data.`}</li>\n      <li parentName=\"ul\">{`Shopping cart contents. GraphQL supports both guest and logged-in customer carts.`}</li>\n      <li parentName=\"ul\">{`Store configuration values, including theme and CMS settings, the currency code, and supported countries.`}</li>\n    </ul>\n    <p>{`The REST GET endpoints retrieve a wide variety of information on behalf of the merchant. Many of these endpoints are for retrieving backend information. For example, the `}<inlineCode parentName=\"p\">{`GET /V1/customers/search`}</inlineCode>{` endpoint can be used to find a subset of customers that meet certain criteria, such as those that live in a particular state or have a birthday this month. Likewise, the `}<inlineCode parentName=\"p\">{`GET /V1/invoices`}</inlineCode>{` endpoint can return all the recently-generated invoices. This type of functionality is not required for the frontend, so it is not available in GraphQL queries. The queries are designed to improve the customer's user experience by quickly retrieving the data needed to render pages.`}</p>\n    <p>{`Over time, the GraphQL queries will duplicate the functionality of all storefront-facing GET calls, while making it possible to query more data in one request. The main difference will be that GraphQL will support storefront use cases, while REST will support admin use cases.`}</p>\n    <h2 {...{\n      \"id\": \"structure-of-a-query\"\n    }}>{`Structure of a query`}</h2>\n    <p>{`A query contains the following elements:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`The optional keyword `}<inlineCode parentName=\"li\">{`query`}</inlineCode>{`. If no keyword is specified at the beginning of a request, the processor assumes the request is a query.`}</li>\n      <li parentName=\"ul\">{`An operation name for your local implementation. This name is required if you include variables. Otherwise, it is optional.`}</li>\n      <li parentName=\"ul\">{`The query name`}</li>\n      <li parentName=\"ul\">{`The terms to search for. The terms can be in the form of objects, attributes, or a combination. Queries that don't require search terms obtain their context from the customer's authorization token or store ID, both of which are specified in the header of the call.`}</li>\n      <li parentName=\"ul\">{`The output object, which specifies which data the query returns.`}</li>\n    </ul>\n    <p>{`The following example shows the structure of the `}<inlineCode parentName=\"p\">{`cart`}</inlineCode>{` query:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`query myCartQuery{\n  cart(cart_id: String!): Cart\n}\n`}</code></pre>\n    <p>{`In the preceding example, `}<inlineCode parentName=\"p\">{`myCartQuery`}</inlineCode>{` identifies your implementation of the `}<inlineCode parentName=\"p\">{`cart`}</inlineCode>{` query. `}<inlineCode parentName=\"p\">{`cart_id`}</inlineCode>{` is a non-nullable string that defines the cart to query. (The exclamation point indicates the value is non-nullable.) The `}<inlineCode parentName=\"p\">{`Cart`}</inlineCode>{` output object defines which fields to return.`}</p>\n    <p>{`Now let's fully define a query:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`query myCartQuery{\n  cart(cart_id: \"1WxKm8WUm3uFKXLlHXezew5WREfVRPAn\") {\n    items {\n      id\n      quantity\n    }\n    billing_address {\n      firstname\n      lastname\n      postcode\n      }\n    shipping_addresses {\n      firstname\n      lastname\n      postcode\n    }\n  }\n}\n`}</code></pre>\n    <p>{`In this example, we've supplied a cart ID as input, (which was generated by the `}<inlineCode parentName=\"p\">{`createEmptyCart`}</inlineCode>{` mutation). The output includes the `}<inlineCode parentName=\"p\">{`cart_id`}</inlineCode>{` as well as selected information about the items in the cart and the billing and shipping addresses.`}</p>\n    <p>{`The following example shows the query response:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"data\": {\n    \"cart\": {\n      \"items\": [\n        {\n          \"id\": \"5\",\n          \"quantity\": 1\n        }\n      ],\n      \"billing_address\": {\n        \"firstname\": \"Veronica\",\n        \"lastname\": \"Costello\",\n        \"postcode\": \"49628-7978\"\n      },\n      \"shipping_addresses\": [\n        {\n          \"firstname\": \"Veronica\",\n          \"lastname\": \"Costello\",\n          \"postcode\": \"49628-7978\"\n        }\n      ]\n    }\n  }\n}\n`}</code></pre>\n    <InlineAlert variant=\"success\" slots=\"text\" mdxType=\"InlineAlert\" />\n    <p>{`Adobe Commerce and Magento Open Source will not run a query that is too complex. The number of fields, objects, and nodes are factors in determining the complexity of a query.`}</p>\n    <h2 {...{\n      \"id\": \"query-variables\"\n    }}>{`Query variables`}</h2>\n    <p>{`Specifying variables in a query can help increase code re-use. Consider the following requirements when generating a query that contains one or more variables:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`All variables must be declared up-front, immediately after the operation name.`}</li>\n      <li parentName=\"ul\">{`Variables are typed: they can be scalar or an object.`}</li>\n      <li parentName=\"ul\">{`You must use all declared variables. Object variables are defined in JSON.`}</li>\n    </ul>\n    <p>{`The following example declares the `}<inlineCode parentName=\"p\">{`$cart_id`}</inlineCode>{` variable. It is referenced in the `}<inlineCode parentName=\"p\">{`input`}</inlineCode>{` statement.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`query myCartQueryWithVariable($cart_id: String!) {\n  cart(cart_id: $cart_id) {\n    items {\n      id\n      quantity\n    }\n    billing_address {\n      firstname\n      lastname\n      postcode\n    }\n    shipping_addresses {\n      firstname\n      lastname\n      postcode\n    }\n  }\n}\n`}</code></pre>\n    <p>{`Variables are defined separately in JSON:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"cart_id\": \"1WxKm8WUm3uFKXLlHXezew5WREfVRPAn\"\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"mutations\"\n    }}>{`Mutations`}</h2>\n    <p>{`While GraphQL queries perform read operations, mutations change the data. A mutation can create, update, or delete objects and fields. In REST terminology, queries operate like `}<inlineCode parentName=\"p\">{`GET`}</inlineCode>{` requests, while mutations are similar to `}<inlineCode parentName=\"p\">{`POST`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`PUT`}</inlineCode>{`, and `}<inlineCode parentName=\"p\">{`DELETE`}</inlineCode>{`.`}</p>\n    <h3 {...{\n      \"id\": \"structure-of-a-mutation\"\n    }}>{`Structure of a mutation`}</h3>\n    <p>{`A mutation contains the following elements:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`The keyword `}<inlineCode parentName=\"li\">{`mutation`}</inlineCode></li>\n      <li parentName=\"ul\">{`An operation name for your local implementation. This name is required if you include variables. Otherwise, it is optional.`}</li>\n      <li parentName=\"ul\">{`The mutation name`}</li>\n      <li parentName=\"ul\">{`The input object or attributes. Most mutations require an input object that contains data or individual attributes for the application server to process. However, some mutations, such as `}<inlineCode parentName=\"li\">{`createEmptyCart`}</inlineCode>{`, do not require an input object. In this particular case, the authorization token passed with the request provides the needed context.`}</li>\n      <li parentName=\"ul\">{`The output object, which specifies which data the mutation returns.`}</li>\n    </ul>\n    <p>{`The following example shows the structure of the `}<inlineCode parentName=\"p\">{`createCustomer`}</inlineCode>{` mutation:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`mutation myCreateCustomer {\n  createCustomer(\n    input: CustomerInput!\n  ) {\n    CustomerOutput\n  }\n}\n`}</code></pre>\n    <p>{`In this example, `}<inlineCode parentName=\"p\">{`myCreateCustomer`}</inlineCode>{` identifies your implementation.  `}<inlineCode parentName=\"p\">{`CustomerInput`}</inlineCode>{` is a non-nullable object that defines a customer. (The exclamation point indicates the value is non-nullable.) The `}<inlineCode parentName=\"p\">{`CustomerOutput`}</inlineCode>{` object defines which fields to return.`}</p>\n    <p>{`Now let's take a look at a fully-defined mutation. This time, we'll specify the minimum fields needed as input to create a customer (`}<inlineCode parentName=\"p\">{`firstname`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`lastname`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`email`}</inlineCode>{`, and `}<inlineCode parentName=\"p\">{`password`}</inlineCode>{`). We could include the same fields in the output, but GraphQL allows you to return only the data you need, which is the customer `}<inlineCode parentName=\"p\">{`email`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`mutation myCreateCustomerNoVariables {\n  createCustomer(\n    input: {\n      firstname: \"Melanie\"\n      lastname: \"Shaw\"\n      email: \"mshaw@example.com\"\n      password: \"Password1\"\n    }\n  ) {\n    customer {\n      email\n    }\n  }\n}\n`}</code></pre>\n    <p>{`The mutation returns the customer email:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"data\": {\n    \"createCustomer\": {\n      \"customer\": {\n        \"email\" : \"mshaw@example.com\"\n      }\n    }\n  }\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"mutation-input\"\n    }}>{`Mutation input`}</h3>\n    <p>{`A mutation can require either an object as input (as shown above) or one or more scalar values. When specifying an object, you must include the `}<inlineCode parentName=\"p\">{`input: {}`}</inlineCode>{` keyword. When the mutation requires scalar values, specify the field name and value, as shown below:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`mutation myGenerateCustomerToken {\n  generateCustomerToken(\n    email: \"mshaw@example.com\"\n    password: \"Password1\"\n  ) {\n    token\n  }\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"mutation-variables\"\n    }}>{`Mutation variables`}</h3>\n    <p>{`Specifying variables in a mutation can help increase code re-use. Consider the following requirements when generating a mutation that contains one or more variables:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`All variables must be declared up-front, immediately after the operation name.`}</li>\n      <li parentName=\"ul\">{`Variables are typed: they can be scalar or an object.`}</li>\n      <li parentName=\"ul\">{`You must use all declared variables. Object variables are defined in JSON.`}</li>\n    </ul>\n    <p>{`The following example declares the `}<inlineCode parentName=\"p\">{`$CustomerInput`}</inlineCode>{` variable. It is referenced in the `}<inlineCode parentName=\"p\">{`input`}</inlineCode>{` statement.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`mutation myCreateCustomerWithVariables($CustomerInput: CustomerInput!) {\n  createCustomer(\n    input: $CustomerInput\n  ) {\n    customer {\n      email\n    }\n  }\n}\n`}</code></pre>\n    <p>{`The `}<inlineCode parentName=\"p\">{`$CustomerInput`}</inlineCode>{` variable is defined as a JSON object:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"CustomerInput\": {\n    \"firstname\": \"Melanie\",\n    \"lastname\": \"Shaw\",\n    \"email\": \"mshaw@example.com\",\n    \"password\": \"Password1\"\n  }\n}\n`}</code></pre>\n    <p>{`This example updates the customer's email using two scalar variables (`}<inlineCode parentName=\"p\">{`$email`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`$password`}</inlineCode>{`).`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`mutation myUpdateCustomer($email: String!, $password: String!) {\n  updateCustomer(\n    input: {\n      email: $email\n      password: $password\n    }\n  ) {\n    customer {\n      email\n    }\n  }\n}\n`}</code></pre>\n    <p>{`The variables are defined separately.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-json\"\n      }}>{`{\n  \"email\": \"melanie.shaw@example.com\",\n  \"password\": \"Password1\"\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["name","_frontmatter","InlineAlert","props","console","warn","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","mdxType","parentName","variant","slots","isMDXComponent"],"sourceRoot":""}