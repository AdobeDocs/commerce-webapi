---
title: Run Graphql queries and mutations | Commerce Web API
description:
---

# Run Graphql queries and mutations

## Queries

A GraphQL query retrieves data from the application server in a similar manner as a REST GET call. The current set of Adobe Commerce and Magento Open Source GraphQL queries allow a mobile app or browser to render a wide variety of information, including the following:

*  A set of products to be displayed. This can include the entire catalog or those that match customer-specified criteria.
*  Customer data. With a customer token, a query can retrieve basic information about a customer as well as billing and shipping addresses, wish lists, order history, and other sensitive data.
*  Shopping cart contents. GraphQL supports both guest and logged-in customer carts.
*  Store configuration values, including theme and CMS settings, the currency code, and supported countries.

The REST GET endpoints retrieve a wide variety of information on behalf of the merchant. Many of these endpoints are for retrieving backend information. For example, the `GET /V1/customers/search` endpoint can be used to find a subset of customers that meet certain criteria, such as those that live in a particular state or have a birthday this month. Likewise, the `GET /V1/invoices` endpoint can return all the recently-generated invoices. This type of functionality is not required for the frontend, so it is not available in GraphQL queries. The queries are designed to improve the customer's user experience by quickly retrieving the data needed to render pages.

Over time, the GraphQL queries will duplicate the functionality of all storefront-facing GET calls, while making it possible to query more data in one request. The main difference will be that GraphQL will support storefront use cases, while REST will support admin use cases.

## Structure of a query

A query contains the following elements:

*  The optional keyword `query`. If no keyword is specified at the beginning of a request, the processor assumes the request is a query.
*  An operation name for your local implementation. This name is required if you include variables. Otherwise, it is optional.
*  The query name
*  The terms to search for. The terms can be in the form of objects, attributes, or a combination. Queries that don't require search terms obtain their context from the customer's authorization token or store ID, both of which are specified in the header of the call.
*  The output object, which specifies which data the query returns.

The following example shows the structure of the `cart` query:

```graphql
query myCartQuery{
  cart(cart_id: String!): Cart
}
```

In the preceding example, `myCartQuery` identifies your implementation of the `cart` query. `cart_id` is a non-nullable string that defines the cart to query. (The exclamation point indicates the value is non-nullable.) The `Cart` output object defines which fields to return.

Now let's fully define a query:

```graphql
query myCartQuery{
  cart(cart_id: "1WxKm8WUm3uFKXLlHXezew5WREfVRPAn") {
    items {
      id
      quantity
    }
    billing_address {
      firstname
      lastname
      postcode
      }
    shipping_addresses {
      firstname
      lastname
      postcode
    }
  }
}
```

In this example, we've supplied a cart ID as input, (which was generated by the `createEmptyCart` mutation). The output includes the `cart_id` as well as selected information about the items in the cart and the billing and shipping addresses.

The following example shows the query response:

```json
{
  "data": {
    "cart": {
      "items": [
        {
          "id": "5",
          "quantity": 1
        }
      ],
      "billing_address": {
        "firstname": "Veronica",
        "lastname": "Costello",
        "postcode": "49628-7978"
      },
      "shipping_addresses": [
        {
          "firstname": "Veronica",
          "lastname": "Costello",
          "postcode": "49628-7978"
        }
      ]
    }
  }
}
```

<InlineAlert variant="success" slots="text" />

Adobe Commerce and Magento Open Source will not run a query that is too complex. The number of fields, objects, and nodes are factors in determining the complexity of a query.

## Query variables

Specifying variables in a query can help increase code re-use. Consider the following requirements when generating a query that contains one or more variables:

*  All variables must be declared up-front, immediately after the operation name.
*  Variables are typed: they can be scalar or an object.
*  You must use all declared variables. Object variables are defined in JSON.

The following example declares the `$cart_id` variable. It is referenced in the `input` statement.

```graphql
query myCartQueryWithVariable($cart_id: String!) {
  cart(cart_id: $cart_id) {
    items {
      id
      quantity
    }
    billing_address {
      firstname
      lastname
      postcode
    }
    shipping_addresses {
      firstname
      lastname
      postcode
    }
  }
}
```

Variables are defined separately in JSON:

```json
{
  "cart_id": "1WxKm8WUm3uFKXLlHXezew5WREfVRPAn"
}
```

## Staging queries {#staging}

GraphQL allows you to use certain queries to return preview information for staged content. Staging, a Adobe Commerce feature, allows merchants to schedule a set of changes to the storefront that run for a prescribed time in the future. These changes, also known as a _campaign_, are defined within the Admin. Customers do not have access to staged content, and as a result, staging queries have requirements that do not apply to traditional queries and mutations.

[Content Staging](https://docs.magento.com/m2/ee/user_guide/cms/content-staging.html) in the _Merchant User Guide_ describes how to create a campaign.

You can use the following queries to return staged preview information.

*  `categoryList`
*  `products`

<InlineAlert variant="info" slots="text" />

The `products` query does not support full text search in the context of staging, because staged content is not indexed. Therefore, omit the `search` input attribute in your staging `products` queries.

A staging query requires two specialized headers:

Header name | Description
--- | ---
`Authorization Bearer: <authorization_token>` | An admin token. Use a 2FA REST endpoint such as  `POST /V1/tfa/provider/google/authenticate` to generate this token.
`Preview-Version` | A timestamp (seconds since January 1, 1970) that is inside the range of dates of the campaign you are querying.

The application returns an authorization error if you specify an invalid token or do not include both headers. If the specified timestamp does not correspond to a date in a scheduled campaign, the query results reflect the current storefront settings.

The application also returns an error if you specify these headers with any other query or any mutation.

### Example campaign

The example staging queries in this section are based on a simple campaign that creates a custom category and catalog sales rule using the Luma sample data. By default, the custom category and sales rule are disabled but become enabled when the campaign takes effect.

The following steps describe how to create this example campaign.

1. Create a subcategory of **Sale** named **End of Year Sale**. Set the **Enable Category** field to **No**.
1. Add several products to the subcategory.
1. Schedule an update named **End of Year Sale Update** for the subcategory that takes effect at a later date. Configure the update so that the **Enable Category** field is set to **Yes**.
1. Create a catalog sales rule with the following properties:
   *  Set the **Active** switch to **No**.
   *  In the **Conditions** section, define the condition as **Category is <Subcategory_ID>**.
   *  In the **Actions** section, set the **Apply** field to **Apply a percentage of original** and the **Discount Amount** field to **25**.
1. Schedule an update for the catalog sales rule and assign it to the **End of Year Sale Update**. In this update, set the **Active** switch to **Yes**.

#### Staging `products` query

The following query returns information about a product (`24-UG05`) in the **End of Year Sale** campaign. The `Preview-Version` header contains the timestamp for a date that is within the duration of the campaign. When you include the proper headers, the query returns prices with applied discounts. Without the headers, the query returns only default prices.

**Headers:**

```text
Authorization: Bearer hoyz7k697ubv5hcpq92yrtx39i7x10um
Preview-Version: 1576389600
```

**Request:**

```graphql
{
  products(filter: {sku: {eq: "24-UG05"}}) {
    items {
      name
      sku
      price_range {
        minimum_price {
          discount {
            percent_off
            amount_off
          }
          final_price {
            value
            currency
          }
          regular_price {
            value
          }
        }
      }
    }
  }
}
```

**Response with headers:**

```json
{
  "data": {
    "products": {
      "items": [
        {
          "name": "Go-Get'r Pushup Grips",
          "sku": "24-UG05",
          "price_range": {
            "minimum_price": {
              "discount": {
                "percent_off": 25,
                "amount_off": 4.75
              },
              "final_price": {
                "value": 14.25,
                "currency": "USD"
              },
              "regular_price": {
                "value": 19
              }
            }
          }
        }
      ]
    }
  }
}
```

**Response without headers:**

```json
{
  "data": {
    "products": {
      "items": [
        {
          "name": "Go-Get'r Pushup Grips",
          "sku": "24-UG05",
          "price_range": {
            "minimum_price": {
              "discount": {
                "percent_off": 0,
                "amount_off": 0
              },
              "final_price": {
                "value": 19,
                "currency": "USD"
              },
              "regular_price": {
                "value": 19
              }
            }
          }
        }
      ]
    }
  }
}
```

#### Staging `categoryList` query

In this example campaign, the **End of Year Sale** subcategory and a catalog price rule are disabled when the campaign is not in effect. When you specify valid headers, the `categoryList`query returns full details about the custom category. Otherwise, the query returns an empty array.

**Headers:**

```text
Authorization: Bearer hoyz7k697ubv5hcpq92yrtx39i7x10um
Preview-Version: 1576389600
```

**Request:**

```graphql
{
  categoryList(filters: {ids: {eq: "43"}}) {
    name
    level
    products(
      sort: {
        price: ASC
      }
      pageSize: 20
      currentPage: 1
    ) {
      total_count
      items {
        name
        sku
        price_range {
          minimum_price {
            discount {
              amount_off
              percent_off
            }
            final_price {
              value
            }
            regular_price {
              value
            }
          }
        }
      }
    }
  }
}
```

**Response with headers:**

```json
{
  "data": {
    "categoryList": [
      {
        "name": "End of Year Sale",
        "level": 3,
        "products": {
          "total_count": 4,
          "items": [
            {
              "name": "Solo Power Circuit",
              "sku": "240-LV07",
              "price_range": {
                "minimum_price": {
                  "discount": {
                    "amount_off": 3.5,
                    "percent_off": 25
                  },
                  "final_price": {
                    "value": 10.5
                  },
                  "regular_price": {
                    "value": 14
                  }
                }
              }
            },
            {
              "name": "Quest Lumaflex&trade; Band",
              "sku": "24-UG01",
              "price_range": {
                "minimum_price": {
                  "discount": {
                    "amount_off": 4.75,
                    "percent_off": 25
                  },
                  "final_price": {
                    "value": 14.25
                  },
                  "regular_price": {
                    "value": 19
                  }
                }
              }
            },
            {
              "name": "Go-Get'r Pushup Grips",
              "sku": "24-UG05",
              "price_range": {
                "minimum_price": {
                  "discount": {
                    "amount_off": 4.75,
                    "percent_off": 25
                  },
                  "final_price": {
                    "value": 14.25
                  },
                  "regular_price": {
                    "value": 19
                  }
                }
              }
            },
            {
              "name": "Gabrielle Micro Sleeve Top",
              "sku": "WS02",
              "price_range": {
                "minimum_price": {
                  "discount": {
                    "amount_off": 7.00,
                    "percent_off": 25
                  },
                  "final_price": {
                    "value": 21
                  },
                  "regular_price": {
                    "value": 28
                  }
                }
              }
            }
          ]
        }
      }
    ]
  }
}
```
**Response without headers:**

```json
{
  "data": {
    "categoryList": []
  }
}
```

## Introspection queries

Introspection queries allow you to return information about the schema. For example, you might want a list of GraphQL queries or details about a specific data type. The GraphQL specification determines the structure of introspection queries. See [Introspection](https://graphql.org/learn/introspection/) for more information.

An introspection query returns the same result whether or not you assign it an operation name, such as `IntrospectionQuery`.

### Disable introspection querying

Introspection querying is enabled by default. To disable it in production mode to improve security, add the following to your `app/etc/env.php` file.

```php
'graphql' => [
    'disable_introspection' => true,
]
```

### Example introspection queries

#### Return a list of queries

The following query returns a list of queries.

**Request:**

```graphql
query IntrospectionQuery {
  __schema {
    queryType {
      fields {
        name
        description
        type{
         name
         kind
        }
      }
    }
  }
}
```

#### Return a list of mutations

The following query returns a list of mutations.

**Request:**

```graphql
query IntrospectionQuery {
  __schema {
    mutationType {
      fields {
        name
        description
        type{
         name
         kind
        }
      }
    }
  }
}
```
#### Get details about a data type

The following introspection query returns details about the `ProductAttributeFilterInput` data type.

**Request:**

```graphql
query IntrospectionQuery {
  __type(name: "ProductAttributeFilterInput") {
    name
    kind
    description
    inputFields {
      name
      description
      defaultValue
    }
    fields {
      name
      args {
        name
        description
        type {
          kind
          name
        }
      }
      type {
        kind
        name
      }
    }
  }
}
```

**Response:**

```json
{
  "data": {
    "__type": {
      "name": "ProductAttributeFilterInput",
      "kind": "INPUT_OBJECT",
      "description": "ProductAttributeFilterInput defines the filters to be used in the search. A filter contains at least one attribute, a comparison operator, and the value that is being searched for.",
      "inputFields": [
        {
          "name": "category_id",
          "description": "Filter product by category id",
          "defaultValue": null
        },
        {
          "name": "description",
          "description": "Attribute label: Description",
          "defaultValue": null
        },
        {
          "name": "name",
          "description": "Attribute label: Product Name",
          "defaultValue": null
        },
        {
          "name": "price",
          "description": "Attribute label: Price",
          "defaultValue": null
        },
        {
          "name": "short_description",
          "description": "Attribute label: Short Description",
          "defaultValue": null
        },
        {
          "name": "sku",
          "description": "Attribute label: SKU",
          "defaultValue": null
        },
        {
          "name": "url_key",
          "description": "The part of the URL that identifies the product",
          "defaultValue": null
        }
      ],
      "fields": null
    }
  }
}
```

## Mutations

While GraphQL queries perform read operations, mutations change the data. A mutation can create, update, or delete objects and fields. In REST terminology, queries operate like `GET` requests, while mutations are similar to `POST`, `PUT`, and `DELETE`.

### Structure of a mutation

A mutation contains the following elements:

*  The keyword `mutation`
*  An operation name for your local implementation. This name is required if you include variables. Otherwise, it is optional.
*  The mutation name
*  The input object or attributes. Most mutations require an input object that contains data or individual attributes for the application server to process. However, some mutations, such as `createEmptyCart`, do not require an input object. In this particular case, the authorization token passed with the request provides the needed context.
*  The output object, which specifies which data the mutation returns.

The following example shows the structure of the `createCustomer` mutation:

```graphql
mutation myCreateCustomer {
  createCustomer(
    input: CustomerInput!
  ) {
    CustomerOutput
  }
}
```

In this example, `myCreateCustomer` identifies your implementation.  `CustomerInput` is a non-nullable object that defines a customer. (The exclamation point indicates the value is non-nullable.) The `CustomerOutput` object defines which fields to return.

Now let's take a look at a fully-defined mutation. This time, we'll specify the minimum fields needed as input to create a customer (`firstname`, `lastname`, `email`, and `password`). We could include the same fields in the output, but GraphQL allows you to return only the data you need, which is the customer `email`.

```graphql
mutation myCreateCustomerNoVariables {
  createCustomer(
    input: {
      firstname: "Melanie"
      lastname: "Shaw"
      email: "mshaw@example.com"
      password: "Password1"
    }
  ) {
    customer {
      email
    }
  }
}
```

The mutation returns the customer email:

```json
{
  "data": {
    "createCustomer": {
      "customer": {
        "email" : "mshaw@example.com"
      }
    }
  }
}
```

### Mutation input

A mutation can require either an object as input (as shown above) or one or more scalar values. When specifying an object, you must include the `input: {}` keyword. When the mutation requires scalar values, specify the field name and value, as shown below:

```graphql
mutation myGenerateCustomerToken {
  generateCustomerToken(
    email: "mshaw@example.com"
    password: "Password1"
  ) {
    token
  }
}
```

### Mutation variables

Specifying variables in a mutation can help increase code re-use. Consider the following requirements when generating a mutation that contains one or more variables:

*  All variables must be declared up-front, immediately after the operation name.
*  Variables are typed: they can be scalar or an object.
*  You must use all declared variables. Object variables are defined in JSON.

The following example declares the `$CustomerInput` variable. It is referenced in the `input` statement.

```graphql
mutation myCreateCustomerWithVariables($CustomerInput: CustomerInput!) {
  createCustomer(
    input: $CustomerInput
  ) {
    customer {
      email
    }
  }
}
```

The `$CustomerInput` variable is defined as a JSON object:

```json
{
  "CustomerInput": {
    "firstname": "Melanie",
    "lastname": "Shaw",
    "email": "mshaw@example.com",
    "password": "Password1"
  }
}
```

This example updates the customer's email using two scalar variables (`$email`, `$password`).

```graphql
mutation myUpdateCustomer($email: String!, $password: String!) {
  updateCustomer(
    input: {
      email: $email
      password: $password
    }
  ) {
    customer {
      email
    }
  }
}
```

The variables are defined separately.

```json
{
  "email": "melanie.shaw@example.com",
  "password": "Password1"
}
```
