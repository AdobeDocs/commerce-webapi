{"version":3,"file":"component---src-pages-graphql-develop-extend-existing-schema-md-645139ae588a5bb12c2b.js","mappings":"oRAMaA,EAAe,CAAC,EACvBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAW,GAGhC,IAFDC,EAAU,EAAVA,WACGC,GAAK,YAER,OAAO,SAACJ,GAAS,UAAKD,EAAiBK,EAAK,CAAED,WAAYA,EAAYE,QAAQ,eAG5E,eACE,GAAM,qCAAmC,sCAE3C,iMAAkL,eAAIC,WAAW,KAAG,aAAmB,oGAAoG,uBAAYA,WAAW,KAAG,mBAAiC,6PACtX,eACE,GAAM,qBAAmB,sBAE3B,iIACA,qGAAsF,uBAAYA,WAAW,KAAG,oBAAkC,2BAA2B,uBAAYA,WAAW,KAAG,sBAAoC,oCAAoC,uBAAYA,WAAW,KAAG,YAA0B,oEAAoE,cAAGA,WAAW,IACjZ,KAAQ,uFAAqF,sBAClE,0DAC/B,uFACA,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBAAkB,kQAuBnC,4CAA6B,uBAAYA,WAAW,KAAG,oBAAkC,kFAAkF,uBAAYA,WAAW,KAAG,mBAAiC,kCAAkC,uBAAYA,WAAW,KAAG,yBAAuC,MAAM,uBAAYA,WAAW,KAAG,OAAqB,gBAC9X,mBAAG,uBAAYA,WAAW,KAAG,+CAC7B,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBAAkB,8WASnC,iFAAkE,uBAAYA,WAAW,KAAG,8CAA4D,iCAAiC,uBAAYA,WAAW,KAAG,oBAAkC,4DACrP,oBACE,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAI,QAAS,uBAAYA,WAAW,KAAG,oBAAkC,sIAAsI,uBAAYA,WAAW,KAAG,oBAAkC,2CAA2C,uBAAYA,WAAW,KAAG,QAAsB,+DAEtX,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAI,QAAS,uBAAYA,WAAW,KAAG,sBAAoC,8EAA8E,uBAAYA,WAAW,KAAG,oBAAkC,gIAGvO,eACE,GAAM,2BAAyB,4BAEjC,6EAA8D,uBAAYA,WAAW,KAAG,UAAwB,SAAS,uBAAYA,WAAW,KAAG,SAAuB,mBAAmB,uBAAYA,WAAW,KAAG,WAAyB,oGAChP,sDAAuC,uBAAYA,WAAW,KAAG,0DAAwE,kFAAkF,uBAAYA,WAAW,KAAG,UAAwB,+DAC7Q,mBAAG,uBAAYA,WAAW,KAAG,8EAC7B,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBAAc,q6BA+B/B,eACE,GAAM,6BAA2B,8BAEnC,gEAAiD,uBAAYA,WAAW,KAAG,eAA6B,mCACxG,qEAAsD,uBAAYA,WAAW,KAAG,sBAAoC,YAAY,uBAAYA,WAAW,KAAG,YAA0B,gCAAgC,uBAAYA,WAAW,KAAG,sBAAoC,WAClR,sEAAuD,uBAAYA,WAAW,KAAG,sBAAoC,uCAAuC,uBAAYA,WAAW,KAAG,2BAAyC,MAC/N,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBAAc,yeAY/B,oDAAqC,uBAAYA,WAAW,KAAG,eAA6B,mBAAmB,uBAAYA,WAAW,KAAG,uBAAqC,2BAC9K,qBAAK,iBAAMA,WAAW,MAClB,UAAa,oBAAkB,gIAKnC,eACE,GAAM,kBAAgB,mBAExB,oBACE,eAAIA,WAAW,OAAK,cAAGA,WAAW,KAC9B,KAAQ,YAAU,4CAEtB,eAAIA,WAAW,OAAK,cAAGA,WAAW,KAC9B,KAAQ,gBAAc,eAE1B,eAAIA,WAAW,OAAK,cAAGA,WAAW,KAC9B,KAAQ,uFAAqF,wBAKvG,CAEAJ,EAAWK,gBAAiB,C","sources":["webpack://commerce-webapi/./src/pages/graphql/develop/extend-existing-schema.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/commerce-webapi/commerce-webapi/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"extend-an-existing-graphql-schema\"\n    }}>{`Extend an existing GraphQL schema`}</h1>\n    <p>{`You can extend the default GraphQL schema to add attributes and data types, modify existing resolver behavior, and add features using other extension points. GraphQL uses `}<em parentName=\"p\">{`stitching`}</em>{` to assemble a single unified schema out of the many schemas defined in individual modules. All `}<inlineCode parentName=\"p\">{`schema.graphqls`}</inlineCode>{` files are stitched together to a single schema. In this process, all nodes with the same type (such as type, interface, and enum) and name are stitched together and recursively extended/overridden. This process is similar to how XML merging works.`}</p>\n    <h2 {...{\n      \"id\": \"extend-the-schema\"\n    }}>{`Extend the schema`}</h2>\n    <p>{`The first step to retrieve a custom field in an existing query is to extend the appropriate schema object.`}</p>\n    <p>{`In the following example, we will change the description of an existing field (`}<inlineCode parentName=\"p\">{`attribute_set_id`}</inlineCode>{`) and add a new field (`}<inlineCode parentName=\"p\">{`attribute_set_name`}</inlineCode>{`) to the GraphQL schema for the `}<inlineCode parentName=\"p\">{`products`}</inlineCode>{` query. Common use cases require adding fields to the database. `}<a parentName=\"p\" {...{\n        \"href\": \"https://developer.adobe.com/commerce/php/development/components/declarative-schema/\"\n      }}>{`Declarative Schema`}</a>{` describes how to add a custom field to the database.`}</p>\n    <p>{`The simplified structure of the query schema to get products is:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`schema {\n    query: Query\n    ...\n}\n\ntype Query {\n    products (...): Products\n    ...\n}\n\ntype Products {\n    items: [ProductInterface]\n    ...\n}\n\ninterface ProductInterface {\n    id: Int\n    name: String\n    sku: String\n    ...\n}\n`}</code></pre>\n    <p>{`We need to extend the `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{`, since that is the schema object for a product. We can do this by creating a `}<inlineCode parentName=\"p\">{`schema.graphqls`}</inlineCode>{` file in our custom module's (`}<inlineCode parentName=\"p\">{`ExampleCorp/CustomGQL`}</inlineCode>{`) `}<inlineCode parentName=\"p\">{`etc`}</inlineCode>{` directory.`}</p>\n    <p><inlineCode parentName=\"p\">{`ExampleCorp_CustomGQL/etc/schema.graphqls`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`interface ProductInterface {\n    attribute_set_id: Int\n        @doc(description: \"ID of the attribute set assigned to the product\")\n    attribute_set_name: String\n        @doc(description: \"Name of attribute set assigned to the product\")\n        @resolver(class: \"\\\\\\\\ExampleCorp\\\\\\\\CustomGQL\\\\\\\\Model\\\\\\\\Resolver\\\\\\\\ProductAttributeSetNameResolver\")\n}\n`}</code></pre>\n    <p>{`The above schema file is merged with the schema present at `}<inlineCode parentName=\"p\">{`Magento_CatalogGraphQl/etc/schema.graphqls`}</inlineCode>{` which contains the original `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{` object. Our schema file contains the following fields:`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`The `}<inlineCode parentName=\"p\">{`attribute_set_id`}</inlineCode>{` field is already present in the original schema, so the field described in our new schema will override the field present in the `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{` object. This example only changes the `}<inlineCode parentName=\"p\">{`@doc`}</inlineCode>{` annotation content to demonstrate how the process works.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`The `}<inlineCode parentName=\"p\">{`attribute_set_name`}</inlineCode>{` field is not present in the orignal schema, so the field is added to the `}<inlineCode parentName=\"p\">{`ProductInterface`}</inlineCode>{` object by extending it. For our new field, we set a description and a resolver class to resolve the data to be returned.`}</p>\n      </li>\n    </ul>\n    <h2 {...{\n      \"id\": \"resolve-the-field-value\"\n    }}>{`Resolve the field value`}</h2>\n    <p>{`In the resolver, we get the relevant data based on the `}<inlineCode parentName=\"p\">{`$value`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`$args`}</inlineCode>{` passed to the `}<inlineCode parentName=\"p\">{`resolve`}</inlineCode>{` method. This can be done using a repository interface or a resource model of the custom field.`}</p>\n    <p>{`In our example scenario, we use `}<inlineCode parentName=\"p\">{`Magento\\\\Catalog\\\\Api\\\\AttributeSetRepositoryInterface`}</inlineCode>{` to get the attribute set name for a given attribute set ID obtained from the `}<inlineCode parentName=\"p\">{`$value`}</inlineCode>{` argument and return that as the resolution for the field.`}</p>\n    <p><inlineCode parentName=\"p\">{`ExampleCorp_CustomGQL/Model/Resolver/ProductAttributeSetNameResolver.php`}</inlineCode></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`<?php\n\nnamespace ExampleCorp\\\\CustomGQL\\\\Model\\\\Resolver;\n\nuse Magento\\\\Catalog\\\\Api\\\\AttributeSetRepositoryInterface;\nuse Magento\\\\Framework\\\\GraphQl\\\\Config\\\\Element\\\\Field;\nuse Magento\\\\Framework\\\\GraphQl\\\\Query\\\\ResolverInterface;\nuse Magento\\\\Framework\\\\GraphQl\\\\Schema\\\\Type\\\\ResolveInfo;\n\n/**\n * Class to resolve custom attribute_set_name field in product GraphQL query\n */\nclass ProductAttributeSetNameResolver implements ResolverInterface\n{\n    /**\n     * @var AttributeSetRepositoryInterface\n     */\n    private $setRepository;\n\n    public function __construct(AttributeSetRepositoryInterface $setRepository)\n    {\n        $this->setRepository = $setRepository;\n    }\n\n    public function resolve(Field $field, $context, ResolveInfo $info, array $value = null, array $args = null)\n    {\n        return $this->setRepository->get($value['attribute_set_id'])->getAttributeSetName();\n    }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"extend-configuration-data\"\n    }}>{`Extend configuration data`}</h2>\n    <p>{`You can add your own configuration to the `}<inlineCode parentName=\"p\">{`storeConfig`}</inlineCode>{` query within your own module.`}</p>\n    <p>{`To do this, configure the constructor argument `}<inlineCode parentName=\"p\">{`extendedConfigData`}</inlineCode>{` in the `}<inlineCode parentName=\"p\">{`argument`}</inlineCode>{` node in your area-specific `}<inlineCode parentName=\"p\">{`etc/graphql/di.xml`}</inlineCode>{` file.`}</p>\n    <p>{`The following example adds an array-item to the `}<inlineCode parentName=\"p\">{`extendedConfigData`}</inlineCode>{` array within the construct of the `}<inlineCode parentName=\"p\">{`StoreConfigDataProvider`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-xml\"\n      }}>{`<?xml version=\"1.0\" ?>\n<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"urn:magento:framework:ObjectManager/etc/config.xsd\">\n  <type name=\"Magento\\\\StoreGraphQl\\\\Model\\\\Resolver\\\\Store\\\\StoreConfigDataProvider\">\n    <arguments>\n      <argument name=\"extendedConfigData\" xsi:type=\"array\">\n        <item name=\"section_group_field\" xsi:type=\"string\">section/group/field</item>\n      </argument>\n    </arguments>\n  </type>\n</config>\n`}</code></pre>\n    <p>{`You must also extend the type `}<inlineCode parentName=\"p\">{`storeConfig`}</inlineCode>{` within in the `}<inlineCode parentName=\"p\">{`etc/schema.graphqls`}</inlineCode>{` file, as shown below:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-graphql\"\n      }}>{`type StoreConfig {\n    section_group_field : String  @doc(description: \"Extended Config Data - section/group/field\")\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"related-topics\"\n    }}>{`Related topics`}</h2>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"index.md\"\n        }}>{`Define the GraphQL schema for a module`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"resolvers.md\"\n        }}>{`Resolvers`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"https://developer.adobe.com/commerce/php/development/components/declarative-schema/\"\n        }}>{`Declarative schema`}</a></li>\n    </ul>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}