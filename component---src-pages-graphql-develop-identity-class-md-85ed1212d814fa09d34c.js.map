{"version":3,"file":"component---src-pages-graphql-develop-identity-class-md-85ed1212d814fa09d34c.js","mappings":"mRAMaA,EAAe,CAAC,EACvBC,EAAc,CAClBD,aAAAA,GAEIE,EAAYC,EAAAA,EACH,SAASC,EAAW,GAGhC,IAFDC,EAAU,EAAVA,WACGC,GAAK,YAER,OAAO,SAACJ,GAAS,UAAKD,EAAiBK,EAAK,CAAED,WAAYA,EAAYE,QAAQ,eAG5E,eACE,GAAM,kBAAgB,mBAExB,sIAAuH,uBAAYC,WAAW,KAAG,YAA0B,qKAAqK,uBAAYA,WAAW,KAAG,kBAAgC,gBAC1Y,mDAAoC,uBAAYA,WAAW,KAAG,mEAAiF,+DAC/I,oBACE,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAI,+CAEpB,eAAIA,WAAW,OACb,cAAGA,WAAW,MAAI,+BAAgC,uBAAYA,WAAW,KAAG,sCAAoD,2SAA2S,uBAAYA,WAAW,KAAG,iBAA+B,oBAAoB,uBAAYA,WAAW,KAAG,kBAAgC,6CAA6C,uBAAYA,WAAW,KAAG,SAAuB,+BAA+B,uBAAYA,WAAW,KAAG,WAAyB,MAAM,uBAAYA,WAAW,KAAG,WAAyB,yMAG/xB,yEAA0D,uBAAYA,WAAW,KAAG,YAA0B,YAC9G,qBAAK,iBAAMA,WAAW,MAClB,UAAa,gBAAc,y0BAmC/B,8BAAe,uBAAYA,WAAW,KAAG,UAAwB,gCAAgC,cAAGA,WAAW,IAC3G,KAAQ,aACP,uBAAYA,WAAW,KAAG,YAA0B,SAAa,qCAAqC,uBAAYA,WAAW,KAAG,YAA0B,0BAA0B,uBAAYA,WAAW,KAAG,YAA0B,6BAA6B,uBAAYA,WAAW,KAAG,YAA0B,4BAC9T,qBAAK,iBAAMA,WAAW,MAClB,UAAa,iBAAe,ibAOpC,CAEAJ,EAAWK,gBAAiB,C","sources":["webpack://commerce-webapi/./src/pages/graphql/develop/identity-class.md"],"sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n/* @jsx mdx */\nimport DefaultLayout from \"/home/runner/work/commerce-webapi/commerce-webapi/node_modules/@adobe/gatsby-theme-aio/src/components/MDXFilter/index.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"identity-class\"\n    }}>{`Identity class`}</h1>\n    <p>{`If you create a cacheable query (similar to those for product, category, and CMS data), then you must create an `}<inlineCode parentName=\"p\">{`Identity`}</inlineCode>{` class for the module. The class must return unique identifiers for cache tags that can be invalidated when an entity changes. Place this class in your module's `}<inlineCode parentName=\"p\">{`Model/Resolver`}</inlineCode>{` directory.`}</p>\n    <p>{`An Identity class implements `}<inlineCode parentName=\"p\">{`Magento\\\\Framework\\\\GraphQl\\\\Query\\\\Resolver\\\\IdentityInterface`}</inlineCode>{`. Your Identity class must contain the following elements:`}</p>\n    <ul>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`Choose a cache tag prefix for the entity.`}</p>\n      </li>\n      <li parentName=\"ul\">\n        <p parentName=\"li\">{`Your implementation of the `}<inlineCode parentName=\"p\">{`getIdentities(array $resolvedData)`}</inlineCode>{` method. The method maps the array of entities data to an array of cache tags, one for each entity. Generally, this method takes an array of query results and creates a cache tag for each entity based on the original string and the unique identifier for each item to be cached. For example, the `}<inlineCode parentName=\"p\">{`getIdentities`}</inlineCode>{` method for the `}<inlineCode parentName=\"p\">{`CatalogGraphQl`}</inlineCode>{` component appends the product ID to the `}<inlineCode parentName=\"p\">{`cat_p`}</inlineCode>{` cache tag prefix, such as `}<inlineCode parentName=\"p\">{`cat_p_1`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`cat_p_2`}</inlineCode>{`, and so on. Usually the method also adds the cache tag without an appended ID to the result array, so all cache records can be removed at once, and not only cache records for specific entities.`}</p>\n      </li>\n    </ul>\n    <p>{`Use following example as the basis for your custom `}<inlineCode parentName=\"p\">{`Identity`}</inlineCode>{` class:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-php\"\n      }}>{`<?php\ndeclare(strict_types=1);\n\nnamespace PathToModule\\\\Model\\\\Resolver\\\\MyModule;\n\nuse Magento\\\\Framework\\\\GraphQl\\\\Query\\\\Resolver\\\\IdentityInterface;\n\n/**\n * Get identities from resolved data\n */\nclass MyIdentity implements IdentityInterface\n{\n    private $cacheTag = \\\\PathToModule\\\\Model\\\\MyEntity::CACHE_TAG;\n\n    /**\n     * Get identity tags from resolved data\n     *\n     * @param array $resolvedData\n     * @return string[]\n     */\n    public function getIdentities(array $resolvedData): array\n    {\n        $ids = [];\n        $items = $resolvedData['items'] ?? [];\n        foreach ($items as $item) {\n            $ids[] = sprintf('%s_%s', $this->cacheTag, $item['entity_id']);\n        }\n        if (!empty($ids)) {\n            $ids[]Â = $this->cacheTag;\n        }\n        return $ids;\n    }\n}\n`}</code></pre>\n    <p>{`Use the `}<inlineCode parentName=\"p\">{`@cache`}</inlineCode>{` directive in your module's `}<a parentName=\"p\" {...{\n        \"href\": \"index.md\"\n      }}><inlineCode parentName=\"a\">{`graphqls`}</inlineCode>{` file`}</a>{` to specify the location to your `}<inlineCode parentName=\"p\">{`Identity`}</inlineCode>{` class. Your module's `}<inlineCode parentName=\"p\">{`graphqls`}</inlineCode>{` file must point to your `}<inlineCode parentName=\"p\">{`Identity`}</inlineCode>{` class, as shown below:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-text\"\n      }}>{`categoryList(\n    filters: CategoryFilterInput @doc(description: \"Identifies which Category filter inputs to search for and return.\")\n): [CategoryTree] @doc(description: \"Returns an array of categories based on the specified filters.\") @resolver(class: \"Magento\\\\\\\\CatalogGraphQl\\\\\\\\Model\\\\\\\\Resolver\\\\\\\\CategoryList\") @cache(cacheIdentity: \"Magento\\\\\\\\CatalogGraphQl\\\\\\\\Model\\\\\\\\Resolver\\\\\\\\Category\\\\\\\\CategoriesIdentity\")\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"sourceRoot":""}